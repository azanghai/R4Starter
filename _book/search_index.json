[["数据整理和总结.html", "数据整理和总结 数据整理 作业 概括你的数据", " 数据整理和总结 在本次研讨会中，我将向您介绍许多关键包，Tidyverse这些包包含大量用于处理整齐格式数据的函数。通过使我们的数据整理可重现（即，通过用 R 进行编码），我们可以在添加新数据时轻松地重新运行分析流程的此阶段。数据整理阶段的可重复性是分析过程的关键部分，但在需要确保其可重复性方面经常被忽视。本次研讨会分为两个部分。第一个重点是数据整理，第二部分是数据总结。 数据整理 概述 我们将首先了解Tidyverse中的一些关键工具，这些工具使我们能够整理和整理数据，使其达到我们可视化和建模所需的格式。Tidyverse 是一个相互“很好地配合”的软件包的集合。它们基于一个共同的理念，即数据以矩形格式（即行和列）表示。这些矩形结构在 Tidyverse 中被称为tibbles。如果您有兴趣，可以在此处tibbles阅读R4DS 书籍中的更多信息。 请观看以下视频，我将在其中引导您完成此工作表。然后我希望您通过在自己的计算机上编写（并运行）脚本来完成内容。 加载Tidyverse 让我们首先看一下数据整理。我们将从 Tidyverse 附带的数据集开始。该数据集mpg包含 1999 年至 2008 年美国 38 种流行车型的燃油经济性数据。 首先，我们需要tidyverse使用以下内容加载库： library(tidyverse) 如果您在没有先在计算机上安装 Tidyverse 的情况下运行此行，您将遇到错误。R 包只需要安装一次，因此如果您想第一次将其加载到库中，则需要使用install.packages(*packagename*)。 对于tidyverse我们需要安装它： install.packages(tidyverse) 安装tidyverse后，您可以使用library()功能将其加载到您的库中。您只需在计算机上安装一次软件包（除非您已更新 R 或者您想要安装特定软件包的最新版本）。当您编写 R 脚本时，您永远不想在脚本主体中拥有该函数install.packages()，就好像其他人运行您的脚本一样，这会更新他们计算机上的包（他们可能不想要）。 数据集mpg mpg数据集作为Tidyverse包帮助文件的一部分被加载，可以使用help(mpg)或者?mpg来查看，我们可以看到下面的说明： Description This dataset contains a subset of the fuel economy data that the EPA makes available on http://fueleconomy.gov. It contains only models which had a new release every year between 1999 and 2008 - this was used as a proxy for the popularity of the car. A data frame with 234 rows and 11 variables. manufacturer - manufacturer model - model name displ - engine displacement, in litres year - year of manufacture cyl - number of cylinders trans -type of transmission drv-f = front-wheel drive, r = rear wheel drive, 4 = 4wd cty - city miles per gallon hwy - highway miles per gallon fl - fuel type class - “type” of car 使用head()和str() 我们可以通过多种方式探索 Tidyverse 加载的数据集mpg。如果我们想查看数据集的前 6 行，我们可以使用该head()函数。 head(mpg) ## # A tibble: 6 × 11 ## manufacturer model displ year cyl trans drv cty hwy ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 audi a4 1.8 1999 4 auto(l5) f 18 29 ## 2 audi a4 1.8 1999 4 manual(m5) f 21 29 ## 3 audi a4 2 2008 4 manual(m6) f 20 31 ## 4 audi a4 2 2008 4 auto(av) f 21 30 ## 5 audi a4 2.8 1999 6 auto(l5) f 16 26 ## 6 audi a4 2.8 1999 6 manual(m5) f 18 26 ## # ℹ 2 more variables: fl &lt;chr&gt;, class &lt;chr&gt; 我们看到它是一个tibble或者说一个矩形数据框，由行和列组成。这是每个观察对应一行的格式tidy。我们将在 R 中运行的大多数分析都涉及tidy数据。在 Tidyverse 中，tibble是表示数据的标准方式。您将花费大量时间整理和整理数据以将其转换为这种格式！通过使用您编写的脚本在 R 中执行此操作，您可以使这个关键阶段可重现。您可以在更新的或不同的数据集上再次运行脚本,因此可能会节省您大量时间！ 我们还可以使用 询问有关数据集结构的信息str()。这将告诉我们有关列的信息、每个变量的类型、行数等。 str(mpg) ## tibble [234 × 11] (S3: tbl_df/tbl/data.frame) ## $ manufacturer: chr [1:234] &quot;audi&quot; &quot;audi&quot; &quot;audi&quot; &quot;audi&quot; ... ## $ model : chr [1:234] &quot;a4&quot; &quot;a4&quot; &quot;a4&quot; &quot;a4&quot; ... ## $ displ : num [1:234] 1.8 1.8 2 2 2.8 2.8 3.1 1.8 1.8 2 ... ## $ year : int [1:234] 1999 1999 2008 2008 1999 1999 2008 1999 1999 2008 ... ## $ cyl : int [1:234] 4 4 4 4 6 6 6 4 4 4 ... ## $ trans : chr [1:234] &quot;auto(l5)&quot; &quot;manual(m5)&quot; &quot;manual(m6)&quot; &quot;auto(av)&quot; ... ## $ drv : chr [1:234] &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; ... ## $ cty : int [1:234] 18 21 20 21 16 18 18 18 16 20 ... ## $ hwy : int [1:234] 29 29 31 30 26 26 27 26 25 28 ... ## $ fl : chr [1:234] &quot;p&quot; &quot;p&quot; &quot;p&quot; &quot;p&quot; ... ## $ class : chr [1:234] &quot;compact&quot; &quot;compact&quot; &quot;compact&quot; &quot;compact&quot; ... 用select()选择列 如果我们愿意，我们可以使用该select()函数选择其中一列。下面我们只选择标题为manufacturer的列。 mpg %&gt;% select(manufacturer) ## # A tibble: 234 × 1 ## manufacturer ## &lt;chr&gt; ## 1 audi ## 2 audi ## 3 audi ## 4 audi ## 5 audi ## 6 audi ## 7 audi ## 8 audi ## 9 audi ## 10 audi ## # ℹ 224 more rows 与select()功能相关的是rename()和您想的一样，它重命名一列。 我们还可以使用该distinct()函数查看数据集中的不同汽车制造商。这为我们提供了不同的制造商名称。如果您想检查数据集是否有（例如）参与者 ID 的重复项，此功能会非常方便。 mpg %&gt;% distinct(manufacturer) ## # A tibble: 15 × 1 ## manufacturer ## &lt;chr&gt; ## 1 audi ## 2 chevrolet ## 3 dodge ## 4 ford ## 5 honda ## 6 hyundai ## 7 jeep ## 8 land rover ## 9 lincoln ## 10 mercury ## 11 nissan ## 12 pontiac ## 13 subaru ## 14 toyota ## 15 volkswagen 用filter()选择行 有时我们可能只想选择数据集中的行子集。我们可以使用该filter()函数来做到这一点。例如，在这里我们过滤数据集以仅包含“honda”制造的汽车。 mpg %&gt;% filter(manufacturer == &quot;honda&quot;) ## # A tibble: 9 × 11 ## manufacturer model displ year cyl trans drv cty hwy ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 honda civic 1.6 1999 4 manual(m5) f 28 33 ## 2 honda civic 1.6 1999 4 auto(l4) f 24 32 ## 3 honda civic 1.6 1999 4 manual(m5) f 25 32 ## 4 honda civic 1.6 1999 4 manual(m5) f 23 29 ## 5 honda civic 1.6 1999 4 auto(l4) f 24 32 ## 6 honda civic 1.8 2008 4 manual(m5) f 26 34 ## 7 honda civic 1.8 2008 4 auto(l5) f 25 36 ## 8 honda civic 1.8 2008 4 auto(l5) f 24 36 ## 9 honda civic 2 2008 4 manual(m6) f 21 29 ## # ℹ 2 more variables: fl &lt;chr&gt;, class &lt;chr&gt; 请注意，我们使用的运算符==表示“等于”。这是一个逻辑运算符,其他逻辑运算符包括小于&lt;、大于&gt;、小于等于&lt;=、大于等于&gt;=和不等于!=。 下面我们过滤制造商为“honda”且制造年份为“1999”的情况。 mpg %&gt;% filter(manufacturer == &quot;honda&quot; &amp; year == &quot;1999&quot;) ## # A tibble: 5 × 11 ## manufacturer model displ year cyl trans drv cty hwy ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 honda civic 1.6 1999 4 manual(m5) f 28 33 ## 2 honda civic 1.6 1999 4 auto(l4) f 24 32 ## 3 honda civic 1.6 1999 4 manual(m5) f 25 32 ## 4 honda civic 1.6 1999 4 manual(m5) f 23 29 ## 5 honda civic 1.6 1999 4 auto(l4) f 24 32 ## # ℹ 2 more variables: fl &lt;chr&gt;, class &lt;chr&gt; 组合功能 我们可以结合使用filter()和select()来过滤制造商为“honda”、制造年份为“1999”的情况，并且我们只想显示这两列以及告诉我们燃油经济性的列(cty和hwy)。 mpg %&gt;% filter(manufacturer == &quot;honda&quot; &amp; year == &quot;1999&quot;) %&gt;% select(manufacturer, year, cty, hwy) ## # A tibble: 5 × 4 ## manufacturer year cty hwy ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 honda 1999 28 33 ## 2 honda 1999 24 32 ## 3 honda 1999 25 32 ## 4 honda 1999 23 29 ## 5 honda 1999 24 32 通过组合几个函数，您可以想象我们可以非常简单地构建一些相当复杂的数据整理规则。 管道操作符%&gt;% 请注意，在上面的这些示例中，我们使用了%&gt;%运算符 - 这称为管道，允许我们将信息从管道的一侧传递到另一侧。您可以将其读作“然后”。Tidyverse 中的所有函数（例如select()和filter()）都称为动词（verbs），它们本身描述了自己的作用。管道是 Tidyverse 中最常用的运算符之一，它允许我们将不同的代码行链接在一起 - 每行的输出作为输入传递到下一行。在此示例中，数据集mpg被传递到distinct()函数，我们在其中请求不同（即唯一）制造商的列表。这个输出本身就是一个向量。向量是一种基本数据结构，包含相同类型的元素 - 例如，一堆数字。我们可以在管道链中添加另一行来告诉我们这个向量中有多少个元素。我们可以将其大声朗读为“获取数据集 mpg，然后计算出不同的制造商名称，然后对它们进行计数”。 mpg %&gt;% distinct(manufacturer) %&gt;% count() ## # A tibble: 1 × 1 ## n ## &lt;int&gt; ## 1 15 整理数据集 整理变量名称 目前，汽车制造商名称均为小写。如果它们采用标题大小写（即每个单词的第一个字母大写），看起来会好得多。我们可以使用该mutate()函数创建一个新列 - 这次，新列的名称,即是我们要使用该str_to_title()函数修改旧列的名称。这将覆盖该列并将manufacturer其替换为首字母大写的新版本。 mpg %&gt;% mutate(manufacturer = str_to_title(manufacturer)) ## # A tibble: 234 × 11 ## manufacturer model displ year cyl trans drv cty hwy ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 Audi a4 1.8 1999 4 auto… f 18 29 ## 2 Audi a4 1.8 1999 4 manu… f 21 29 ## 3 Audi a4 2 2008 4 manu… f 20 31 ## 4 Audi a4 2 2008 4 auto… f 21 30 ## 5 Audi a4 2.8 1999 6 auto… f 16 26 ## 6 Audi a4 2.8 1999 6 manu… f 18 26 ## 7 Audi a4 3.1 2008 6 auto… f 18 27 ## 8 Audi a4 quatt… 1.8 1999 4 manu… 4 18 26 ## 9 Audi a4 quatt… 1.8 1999 4 auto… 4 16 25 ## 10 Audi a4 quatt… 2 2008 4 manu… 4 20 28 ## # ℹ 224 more rows ## # ℹ 2 more variables: fl &lt;chr&gt;, class &lt;chr&gt; 列model也是小写的。我们也来让他首字母大写。我们可以使用该mutate()函数同时处理多个列，如下所示： mpg %&gt;% mutate(manufacturer = str_to_title(manufacturer), model = str_to_title(model)) ## # A tibble: 234 × 11 ## manufacturer model displ year cyl trans drv cty hwy ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 Audi A4 1.8 1999 4 auto… f 18 29 ## 2 Audi A4 1.8 1999 4 manu… f 21 29 ## 3 Audi A4 2 2008 4 manu… f 20 31 ## 4 Audi A4 2 2008 4 auto… f 21 30 ## 5 Audi A4 2.8 1999 6 auto… f 16 26 ## 6 Audi A4 2.8 1999 6 manu… f 18 26 ## 7 Audi A4 3.1 2008 6 auto… f 18 27 ## 8 Audi A4 Quatt… 1.8 1999 4 manu… 4 18 26 ## 9 Audi A4 Quatt… 1.8 1999 4 auto… 4 16 25 ## 10 Audi A4 Quatt… 2 2008 4 manu… 4 20 28 ## # ℹ 224 more rows ## # ℹ 2 more variables: fl &lt;chr&gt;, class &lt;chr&gt; 数据集里有很多列，所以我们只选择manufacturer, model, year, transmission 和 hwy列： mpg %&gt;% mutate(manufacturer = str_to_title(manufacturer), model = str_to_title(model)) %&gt;% select(manufacturer, model, year, trans, hwy) ## # A tibble: 234 × 5 ## manufacturer model year trans hwy ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; ## 1 Audi A4 1999 auto(l5) 29 ## 2 Audi A4 1999 manual(m5) 29 ## 3 Audi A4 2008 manual(m6) 31 ## 4 Audi A4 2008 auto(av) 30 ## 5 Audi A4 1999 auto(l5) 26 ## 6 Audi A4 1999 manual(m5) 26 ## 7 Audi A4 2008 auto(av) 27 ## 8 Audi A4 Quattro 1999 manual(m5) 26 ## 9 Audi A4 Quattro 1999 auto(l5) 25 ## 10 Audi A4 Quattro 2008 manual(m6) 28 ## # ℹ 224 more rows 重新编码变量 在现实世界中，数据集（Data Frames）并不总是以整齐的格式到达我们的计算机。通常，您需要先进行一些数据整理，然后才能对它们进行任何有用的操作。我们将看一个示例，说明如何从杂乱的数据变为整洁的数据。使用的数据集可以在这里下载 my_messy_data &lt;- read_csv(&quot;Dataset/my_data.csv&quot;) my_messy_data 我们对 24 名参与者和 4 个条件进行了反应时间实验，他们在我们的数据文件中编号为 1-4。 head(my_messy_data) ## # A tibble: 6 × 3 ## participant condition rt ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 1 879 ## 2 1 2 1027 ## 3 1 3 1108 ## 4 1 4 765 ## 5 2 1 1042 ## 6 2 2 1050 这是一种重复测量设计，其中一个因素（启动类型,即Prime Type）具有两个水平（A 与 B），第二个因素（目标类型,即Target Type）具有两个水平（A 与 B）。我们想要重新编码我们的数据框，以便它更好地匹配我们的实验设计。首先我们需要像这样重新编码 4 个情况（Condition）： 重新编码Condition列如下： - Condition 1 = Prime A, Target A - Condition 2 = Prime A, Target B - Condition 3 = Prime B, Target A - Condition 4 = Prime B, Target B my_messy_data %&gt;% mutate(condition = recode(condition, &quot;1&quot; = &quot;PrimeA_TargetA&quot;, &quot;2&quot; = &quot;PrimeA_TargetB&quot;, &quot;3&quot; = &quot;PrimeB_TargetA&quot;, &quot;4&quot; = &quot;PrimeB_TargetB&quot;)) %&gt;% head() ## # A tibble: 6 × 3 ## participant condition rt ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1 PrimeA_TargetA 879 ## 2 1 PrimeA_TargetB 1027 ## 3 1 PrimeB_TargetA 1108 ## 4 1 PrimeB_TargetB 765 ## 5 2 PrimeA_TargetA 1042 ## 6 2 PrimeA_TargetB 1050 我们现在需要将我们的条件列分成两个 - 一个用于我们的第一个因素（Prime），另一个用于我们的第二个因素（Target）。separate() 函数正是做这个的 - 当与管道化的tibble一起使用时，它需要知道我们想要分离哪一列，通过分离原始列来创建什么新列，以及我们想要基于什么来进行分离。在下面的示例中，我们告诉 separate() 我们想要将标记为 condition 的列分成两个新列，称为 Prime 和 Target，并且我们想要在要被分离的列中出现 _ 的任何地方进行这种分离。 my_messy_data %&gt;% mutate(condition = recode(condition, &quot;1&quot; = &quot;PrimeA_TargetA&quot;, &quot;2&quot; = &quot;PrimeA_TargetB&quot;, &quot;3&quot; = &quot;PrimeB_TargetA&quot;, &quot;4&quot; = &quot;PrimeB_TargetB&quot;)) %&gt;% separate(col = &quot;condition&quot;, into = c(&quot;Prime&quot;, &quot;Target&quot;), sep = &quot;_&quot;) ## # A tibble: 96 × 4 ## participant Prime Target rt ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1 PrimeA TargetA 879 ## 2 1 PrimeA TargetB 1027 ## 3 1 PrimeB TargetA 1108 ## 4 1 PrimeB TargetB 765 ## 5 2 PrimeA TargetA 1042 ## 6 2 PrimeA TargetB 1050 ## 7 2 PrimeB TargetA 942 ## 8 2 PrimeB TargetB 945 ## 9 3 PrimeA TargetA 943 ## 10 3 PrimeA TargetB 910 ## # ℹ 86 more rows my_messy_data %&gt;% mutate(condition = recode(condition, &quot;1&quot; = &quot;PrimeA_TargetA&quot;, &quot;2&quot; = &quot;PrimeA_TargetB&quot;, &quot;3&quot; = &quot;PrimeB_TargetA&quot;, &quot;4&quot; = &quot;PrimeB_TargetB&quot;)) %&gt;% separate(col = &quot;condition&quot;, into = c(&quot;Prime&quot;, &quot;Target&quot;), sep = &quot;_&quot;) %&gt;% mutate(Prime = factor(Prime), Target = factor(Target)) ## # A tibble: 96 × 4 ## participant Prime Target rt ## &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; ## 1 1 PrimeA TargetA 879 ## 2 1 PrimeA TargetB 1027 ## 3 1 PrimeB TargetA 1108 ## 4 1 PrimeB TargetB 765 ## 5 2 PrimeA TargetA 1042 ## 6 2 PrimeA TargetB 1050 ## 7 2 PrimeB TargetA 942 ## 8 2 PrimeB TargetB 945 ## 9 3 PrimeA TargetA 943 ## 10 3 PrimeA TargetB 910 ## # ℹ 86 more rows pivot 函数 我们将在 R 中进行的大多数分析都要求数据处于整洁或长格式。在这样的数据集中，一行对应一个观测值。在现实世界中，数据很少处于适合分析的正确格式。在 R 中，pivot_wider() 和 pivot_longer() 函数被设计用来重塑我们的数据文件。首先，让我们加载一个处于宽格式的数据文件（即，每行有多个观测值）。它来自一个我们进行了四种条件（标记为 Condition1、Condition2、Condition3 和 Condition4）的实验。除了有四种条件的每一列之外，我们还有一列对应于参与者 ID。数据集中的每个单元格对应一个反应时间（以毫秒为单位）。 my_wide_data &lt;- read_csv(&quot;Dataset/my_wide_data.csv&quot;) ## Rows: 32 Columns: 5 ## ── Column specification ─────────────────────────────────────────── ## Delimiter: &quot;,&quot; ## dbl (5): ID, Condition1, Condition2, Condition3, Condition4 ## ## ℹ Use `spec()` to retrieve the full column specification for this data. ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. pivot_longer() 函数 head(my_wide_data) ## # A tibble: 6 × 5 ## ID Condition1 Condition2 Condition3 Condition4 ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 487 492 499 488 ## 2 2 502 494 517 508 ## 3 3 510 483 488 509 ## 4 4 476 488 513 521 ## 5 5 504 478 513 504 ## 6 6 505 486 503 495 所以，我们可以看到数据文件是宽格式的。我们想要将其重塑为长格式。我们可以使用 pivot_longer() 函数来做到这一点。 最低限度地，我们需要指定我们想要重塑的数据框架，我们想要转换为长格式的列，我们正在创建的新列的名称，以及将保存我们重塑数据框架（data frame）的值的列的名称。我们将输出映射到一个我称之为 my_longer_data 的变量。 my_longer_data &lt;- my_wide_data %&gt;% pivot_longer(cols = c(Condition1, Condition2, Condition3, Condition4), names_to = &quot;Condition&quot;, values_to = &quot;RT&quot;) 现在我们来看看重塑后的数据框架的样子 head(my_longer_data) ## # A tibble: 6 × 3 ## ID Condition RT ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1 Condition1 487 ## 2 1 Condition2 492 ## 3 1 Condition3 499 ## 4 1 Condition4 488 ## 5 2 Condition1 502 ## 6 2 Condition2 494 所以你可以看到我们的数据现在是长格式（或tidy格式），每行一个观察。注意我们的Condition列没有被编码为因子。由于我们的数据集需要反映我们实验的结构，因此让我们将该列转换为因子 - 注意在以下代码中我们现在正在“保存”更改，因为我们没有将输出映射到变量名上。 my_longer_data %&gt;% mutate(Condition = factor(Condition)) %&gt;% head() ## # A tibble: 6 × 3 ## ID Condition RT ## &lt;dbl&gt; &lt;fct&gt; &lt;dbl&gt; ## 1 1 Condition1 487 ## 2 1 Condition2 492 ## 3 1 Condition3 499 ## 4 1 Condition4 488 ## 5 2 Condition1 502 ## 6 2 Condition2 494 pivot_wider()函数 我们可以使用 pivot_wider() 函数来重塑长数据框，使其从长格式转换为宽格式。它的工作方式类似于 pivot_longer()。让我们拿我们新的、长的、数据框并将其转回宽格式。使用 pivot_wider() 时，我们最低需要指定我们想要重塑的数据框，并指定一对参数（names_from 和 values_from），这些参数描述了从哪个列获取输出列的名称，以及从哪个列获取单元格值。 my_wider_data &lt;- my_longer_data %&gt;% pivot_wider(names_from = &quot;Condition&quot;, values_from = &quot;RT&quot;) 我们可以检查我们的数据集是否已经回到宽格式。 head(my_wider_data) ## # A tibble: 6 × 5 ## ID Condition1 Condition2 Condition3 Condition4 ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 487 492 499 488 ## 2 2 502 494 517 508 ## 3 3 510 483 488 509 ## 4 4 476 488 513 521 ## 5 5 504 478 513 504 ## 6 6 505 486 503 495 合并两个数据集 有时你可能需要合并两个数据集。例如，你可能有一个包含阅读时间数据的数据集（就像上面那个）和另一个包含第一个数据集中参与者的个体差异测量的数据集。我们如何才能合并这两个数据集，以便最终得到一个既包括阅读时间数据又包括个体差异测量（我们可能稍后想要协变掉）的数据集？幸运的是，dplyr 包包含了许多连接函数，允许你将不同的tibbles连接在一起。首先，让我们加载包含个体差异测量的数据。该数据集可以在这里下载 individual_diffs &lt;- read_csv(&quot;Dataset/individual_diffs.csv&quot;) 让我们看看个体差异数据的前几行。这个数据集包含了我们参与者的ID号以及智商（iq列）和工作记忆（wm列）的测量值。 head(individual_diffs) ## # A tibble: 6 × 3 ## ID iq wm ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 100 9 ## 2 2 108 8 ## 3 3 116 9 ## 4 4 95 9 ## 5 5 83 11 ## 6 6 73 10 完全合并 我们可以使用其中一个连接函数来组合。有多种选择，包括 full_join()，它包括了我们想要连接的第一个或第二个 tibble 中的所有行。其他选项包括 inner_join()，它包括了第一个和第二个 tibble 中的所有行，以及 left_join() 和 right_join()。 combined_data &lt;- full_join(my_longer_data, individual_diffs, by = &quot;ID&quot;) 我们现在看到我们的数据集按照我们的预期组合在一起了。 combined_data ## # A tibble: 128 × 5 ## ID Condition RT iq wm ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 Condition1 487 100 9 ## 2 1 Condition2 492 100 9 ## 3 1 Condition3 499 100 9 ## 4 1 Condition4 488 100 9 ## 5 2 Condition1 502 108 8 ## 6 2 Condition2 494 108 8 ## 7 2 Condition3 517 108 8 ## 8 2 Condition4 508 108 8 ## 9 3 Condition1 510 116 9 ## 10 3 Condition2 483 116 9 ## # ℹ 118 more rows 左合并 当然，你可能会想，我们可以简单地使用Excel对我们想要的列进行剪切和粘贴，从一个数据集转移到另一个数据集。但是，如果我们的个体差异文件包含了10,000个参与者的ID（以随机顺序排列），而我们只对在两个数据集匹配的情况下进行合并感兴趣呢？ large_ind_diffs &lt;- read_csv(&quot;Dataset/large_ind_diffs.csv&quot;) head(large_ind_diffs) ## # A tibble: 6 × 3 ## ID iq wm ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 6057 93 7 ## 2 2723 86 7 ## 3 1088 97 9 ## 4 8687 87 8 ## 5 4223 77 11 ## 6 369 95 9 我们实际上可以使用另一个连接函数（left_join()）来组合这两个数据集，但只在第一个数据集（函数调用中的my_longer_data）的ID与另一个数据集匹配的情况下进行组合。 left_join(my_longer_data, large_ind_diffs, by = &quot;ID&quot;) ## # A tibble: 128 × 5 ## ID Condition RT iq wm ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 Condition1 487 100 9 ## 2 1 Condition2 492 100 9 ## 3 1 Condition3 499 100 9 ## 4 1 Condition4 488 100 9 ## 5 2 Condition1 502 108 8 ## 6 2 Condition2 494 108 8 ## 7 2 Condition3 517 108 8 ## 8 2 Condition4 508 108 8 ## 9 3 Condition1 510 116 9 ## 10 3 Condition2 483 116 9 ## # ℹ 118 more rows 作业 尝试通过使用 RStudio Desktop 编写你的第一个脚本来重现上面的内容。 概括你的数据 概述 一旦数据集被整理好，我们通常想要做的第一件事之一就是生成摘要统计数据。在这个研讨会中，我们将使用内置于 tidyverse 中的 mpg 数据集。这个数据集包含了许多不同制造商生产的汽车的信息（如发动机大小、燃油经济性等）。我们如何生成（例如）按汽车制造商分组的某个变量的平均值和标准偏差？请观看以下视频，我将引导你完成这个工作表。然后，我希望你通过在自己的机器上编写（并运行）脚本来完成内容。 在继续之前，请记得为这节课设置一个 .Rproj 文件。在你的脚本中，你首先需要加载 tidyverse。 使用 group_by() 和 summarise() "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
